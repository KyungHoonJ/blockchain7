<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Queue</title>
  </head>
  <body>
    <script>
      const queueNode = {
        arr: [],
        enqueue(data) {
          this.arr.push(data);
          // 뒤에서 넣고
        },
        dequeue() {
          return this.arr.shift();
          // 앞에서 뺀다.
        },
        get() {
          return [...this.arr];
          // arr에 직접적으로 접근하지 못하게 하도록, arr 자체를 가져오게 하지 못하도록 한다.
        },
      };
      queueNode.push(0);
      queueNode.push(2);
      queueNode.push(4);
      queueNode.push(6);
      console.log(queueNode.shift());
      console.log(queueNode.get());

      // 아래는 공부하고 싶으면 해보세요.
      class Node {
        // 기본 노드(부모)
        constructor(data) {
          // 생성자에서 data를 저장한다, 정의한다.
          this.data = data;
        }
      }

      class QueueNode extends Node {
        constructor(data) {
          super(data);
          this.head;
        }

        enqueue(data) {
          if (!this.data) {
            this.data = data;
          } else if (this.head) {
            this.head.push(data);
          } else {
            this.head = new QueueNode(data);
          }
        }

        dequeue() {
          const temp = this.data;
          // 첫 데이터를 저장한다. 정의한다.
          if (this.head) {
            // 헤드가 있으면
            this.data = this.head.data;
            // 현재 노드의 데잍터를 헤드의 데이터로 정의한다.
            if (!this.head?.head) {
              // 헤드의 헤드가 없으면(다음 헤드가 마지막 노드면)
              delete this.head;
              // 헤드를 삭제한다.
            } else {
              // 헤드의 헤드가 있으면(현재 노드의 헤드가 마지막 노드가 아니면)
              this.head.shift();
              // 헤드의 shift 메서드를 호출한다.
            }
          } else {
            // 헤드가 없으면 현재 노드가 끝이기 때문에 data를 없애준다.
            this.data = undefined;
          }
          return temp;
          // 첫 데이터를 return, 반환해준다.
        }
      }
    </script>
  </body>
</html>
